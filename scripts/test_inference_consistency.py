#!/usr/bin/env python3
"""
Test Inference Consistency

Reads a classification debug CSV (generated by the agent) and re-runs inference
locally to verify consistency between platforms (e.g., Dev Machine vs RK3566).

Usage:
    python scripts/test_inference_consistency.py --debug-log data/test_agent/classification_debug.csv
"""

import argparse
import csv
import logging
import sys
from pathlib import Path
from typing import Dict, Any

# Add src to path
sys.path.append(str(Path(__file__).parent.parent))

from src.agents.classifier.classifier import EmailClassifier
from src.core.config_loader import ConfigLoader

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def parse_input_string(input_string: str) -> Dict[str, str]:
    """
    Parse the concatenated input string back into components.
    Format: [SUBJECT] {subject} [SENDER] {sender} [BODY] {body}
    
    Note: This is a best-effort parser. It assumes the tags are present.
    """
    try:
        subject_start = input_string.find("[SUBJECT]") + 9
        sender_start = input_string.find("[SENDER]")
        body_start = input_string.find("[BODY]")
        
        subject = input_string[subject_start:sender_start].strip()
        sender = input_string[sender_start+8:body_start].strip()
        body = input_string[body_start+6:].strip()
        
        # Split sender into name and email if possible
        if '<' in sender and '>' in sender:
            from_name = sender.split('<')[0].strip()
            from_email = sender.split('<')[1].strip('>')
        else:
            from_name = ''
            from_email = sender
            
        return {
            'subject': subject,
            'from_name': from_name,
            'from_email': from_email,
            'body_text': body
        }
    except Exception as e:
        logger.warning(f"Failed to parse input string: {e}")
        return {}

def main():
    parser = argparse.ArgumentParser(description='Test inference consistency')
    parser.add_argument('--debug-log', type=Path, help='Path to classification_debug.csv')
    parser.add_argument('--input-string', type=str, help='Single input string to test')
    parser.add_argument('--config', type=Path, default=Path('config/agents/test_agent.yaml'), help='Path to agent config')
    args = parser.parse_args()
    
    if not args.debug_log and not args.input_string:
        logger.error("Must provide either --debug-log or --input-string")
        sys.exit(1)
        
    # Load config to get model paths
    try:
        config = ConfigLoader(args.config)
    except Exception as e:
        logger.error(f"Failed to load config: {e}")
        sys.exit(1)

    # Initialize classifier
    logger.info("Initializing classifier...")
    classifier = EmailClassifier(
        model_path=Path(config.get('classification', 'model_path', 'models/email_classifier.rknn')),
        tokenizer_path=Path(config.get('classification', 'tokenizer_path', 'models/tokenizer')),
        use_model=config.get('classification', 'use_ai_model', False),
        agent_name="consistency_tester"
    )
    
    logger.info(f"Using model: {classifier.use_model}")
    
    if args.input_string:
        logger.info(f"Testing single input: {args.input_string[:100]}...")
        email_data = parse_input_string(args.input_string)
        if not email_data:
            logger.error("Failed to parse input string")
            sys.exit(1)
            
        result = classifier.classify(email_data)
        logger.info(f"Result: {result['category']} (Conf: {result['confidence']:.2f}, Method: {result['method']})")
        return

    # Read debug log
    logger.info(f"Reading debug log: {args.debug_log}")
    
    matches = 0
    total = 0
    
    with open(args.debug_log, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            total += 1
            input_string = row['input_string']
            original_category = row['category']
            original_confidence = float(row['confidence'])
            original_method = row['method']
            
            # Parse input back to email data
            email_data = parse_input_string(input_string)
            if not email_data:
                continue
                
            # Run inference
            result = classifier.classify(email_data)
            
            # Compare
            match = (result['category'] == original_category)
            if match:
                matches += 1
                logger.info(f"✓ Match: {original_category} (Conf: {result['confidence']:.2f} vs {original_confidence:.2f})")
            else:
                logger.warning(f"✗ Mismatch: Local={result['category']} ({result['confidence']:.2f}) vs Log={original_category} ({original_confidence:.2f})")
                logger.warning(f"  Input: {input_string[:100]}...")

    if total > 0:
        logger.info(f"\nResults: {matches}/{total} matches ({matches/total:.1%})")
    else:
        logger.warning("No records found in debug log")

if __name__ == "__main__":
    main()
